(*Load libraries via AppleMods Loader--##########################################################################################################################*)property loader : AppleMods Loaderproperty strlib : missing valueproperty translate : missing valueon __load__(moduleLoader)	tell moduleLoader		set strlib to loadModule("string")	end tellend __load__########################################################################################################################################################on NewDialog(msg, scriptPath)	set translate to load script file (scriptPath & "pastybridge:pytranslate.scpt")	copy my Dialog to x	set x's message to msg	x's set_path(scriptPath)	return xend NewDialogscript Dialog	property _myPath : missing value --		(** Folder containing ASDialog. *)		property message : missing value --			(** Message to the user explaining the dialog. *)	property _widgets : {} --					(** List of widgets that will be displayed (added to every time an add_*() routine is called). *)	property _cancelbutton : missing value --	(** Button that will stop the script if clicked. *)	property _title : "" --						(** Window title of the dialog. *)			(**	 * Set the folder path which contains ASDialog.	 *	 * It is important ASDialog knows where it is. That is the only	 * way it can call the python bindings.	 *	 * @param	String	The folder containing ASDialog.	 * @return	void	 *)	on set_path(pth)		set _myPath to pth		return	end set_path			(**	 * Adds a title to the dialog window.	 *	 * @param	String	The window title.	 * @return	void	 *)	on add_title(title)		set _title to title		return	end add_title			(*	Routines for adding widgets	*)		(**	 * Adds custom buttons to the dialog.	 *	 * This is not mandatory. The default {Cancel, OK} buttons will	 * be used if no buttons are specified.	 *	 * @param	List		Names of the buttons, in order from left to right.	 * @param	String	The button that should be clicked when the user presses enter (can be null or empty string if a default button is not desired).	 * @param	String	Stops the script (can be null or empty string if a cancel button is not desired).	 * @return	Dialog	The dialog the buttons belong to.	 *)	on add_buttons(buttonList, okbutton, cancelbutton)		set _cancelbutton to cancelbutton		set vals to {¬			{"buttons", buttonList}, ¬			{"okButton", okbutton}, ¬			{"cancelButton", cancelbutton}}		return _add_widget("buttons", vals)	end add_buttons		(**	 * Adds a checkbox to the dialog.	 *	 * Unlike other widgets, the label for the checkbox will be on the right side of the window.	 *	 * @param	String	The text description for the checkbox.	 * @param	Bool	Initial state of the checkbox.	 * @return	Dialog	The dialog the checkbox belongs to.	 *)	on add_checkbox(label, checked)		set vals to {¬			{"label", label}, ¬			{"checked", checked}}		return _add_widget("checkbox", vals)	end add_checkbox		(**	 * Adds a dropdown list menu to the dialog (where only one option can be chosen).	 *	 * @param	{String+Number}	Possible values for the user to choose.	 * @param	String				The text description for the dropdown.	 * @param	String+Number		Initial value shown in the dropdown.	 * @return	Dialog				The dialog the dropdown belongs to.	 *)	on add_dropdown(values, label, defaultValue)		set vals to {¬			{"label", label}, ¬			{"values", translate's list_to_python(values)}, ¬			{"defaultValue", defaultValue}}		return _add_widget("dropdown", vals)	end add_dropdown			(**	 * Adds a text field for user input.	 *	 * @param	String	The text description for the text field.	 * @param	String	Initial value shown in the text field.	 * @return	Dialog	The dialog the dropdown belongs to.	 *)	on add_text_field(label, defaultValue)		set vals to {¬			{"label", label}, ¬			{"defaultValue", defaultValue}}		return _add_widget("textField", vals)	end add_text_field			(**	 * Adds a group of radio buttons to the dialog.	 *	 * @param	{String+Number}	Possible values for the user to choose.	 * @param	String				The text description for the radio group.	 * @param	String+Number		Initial chosen value.	 * @return	Dialog				The dialog the radio buttons belong to.	 *)	on add_radio_buttons(buttonList, label, defaultButton)		set vals to {¬			{"label", label}, ¬			{"choices", buttonList}, ¬			{"defaultButton", defaultButton}}		return _add_widget("radioButtons", vals)	end add_radio_buttons			(**	 * Same as add_separator_with_label, but without adding a label.	 *	 * @return	Dialog	The dialog the radio buttons belong to.	 *)	on add_separator()		return add_separator_with_label("")	end add_separator			(**	 * Adds a separating line between elements.	 *	 * @param	String	The text description for the separator.	 * @return	Dialog	The dialog the radio buttons belong to.	 *)	on add_separator_with_label(label)		set vals to {¬			{"label", label}}		return _add_widget("separator", vals)	end add_separator_with_label				(**	 * Pops the dialog up to the user and returns the values the user chose in an Associative Array.	 *	 * Must be called after widgets have been added to the dialog, otherwise it won't do anything.	 *	 * @return	AssociativeArray	 *)	on display()		set vals to do shell script _compile_shell_script()		set returnedData to _unserialize(vals)		if readKey("button returned") of returnedData is _cancelbutton then			error number -128		end if		return returnedData	end display									(**	 * Create an AssociativeArray with widget properties and add to the list of widgets.	 *	 * @param	String	The type of widget (i.e.: buttons, separator, checkbox, …).	 * @return	Dialog	 *)	on _add_widget(widgetType, widgetProperties)		set array to translate's newAssociativeArray()		set widgetProperties to {{"name", widgetType}} & widgetProperties		repeat with i from 1 to (count widgetProperties)			set {k, v} to {item 1, item 2} of item i of widgetProperties			array's setKey(k, v)		end repeat		set end of _widgets to array		return me	end _add_widget			(**	 * Compiles the arguments together and creates the	 * formatted shell command for calling the python bindings.	 *	 * @return	String	 *)	on _compile_shell_script()		set args to _compile_args()		set pieces to {"python", "-B", quoted form of POSIX path of (_myPath & "asdialog.py"), args}		return strlib's implode(pieces, space)	end _compile_shell_script			(**	 * Compiles together all of the arguments to be sent to the python bindings,	 * including serializing all of the widget arrays.	 *	 * @return	List	 *)	on _compile_args()		set args to {quoted form of message, quoted form of _title}		repeat with i from 1 to (count _widgets)			set end of args to quoted form of (translate's array_to_python(item i of _widgets))		end repeat		return args	end _compile_args			(**	 * Goes through and makes sure that all values have been unserialized.	 *	 * This should be implemented in AssociativeArray's unserialize instead.	 *	 * @param	String	Value returned from python.	 * @return	AssociativeArray	 *)	on _unserialize(vals)		set valueArray to translate's array_to_applescript(vals)		set {keys, values} to valueArray's {getKeys(), getValues()}				repeat with i from 1 to (count keys)			set {k, v} to {item i of keys, item i of values}			if v contains "|" then				valueArray's setKey(k, translate's list_to_applescript(v))			end if		end repeat		return valueArray	end _unserializeend script